from flask import Flask, request, jsonify
import logging
import pyodbc
from fuzzywuzzy import fuzz, process
from spacy_ner import initialize_matcher, extract_entities  # Import from spacy_ner.py
from load_data import load_abend_data
import bcrypt
import secrets
import string
import win32com.client as win32
import pyttsx3

# Initialize Flask app
app = Flask(__name__)

# Set up logging
logging.basicConfig(level=logging.DEBUG)

# Initialize text-to-speech engine
tts_engine = pyttsx3.init()

# Connection string for database (update as needed)
conn_str = (
    r'DRIVER={SQL Server};'
    r'SERVER=SDC01ASRSQTD01S\TSQLINST01;'
    r'DATABASE=ASPIRE;'
    r'Trusted_Connection=yes;'
)

# Flags and state variables
expecting_user_id = False
expecting_otp = False
user_id_for_reset = None
otp_store = {}
suggested_term = None

# Small talk and utility responses with flexible matching
small_talk_responses = {
    "how are you": "I'm just a bot, but I'm doing great! How about you?",
    "how's it going": "I'm here and ready to help! How can I assist you?",
    "what's up": "Not much, just here to assist you! How can I help?",
    "good morning": "Good morning! How can I assist you today?",
    "good evening": "Good evening! What can I do for you?",
    "good afternoon": "Good afternoon! How can I help?",
    "ok": "Okay! Let me know if there's anything else you need.",
    "fine": "Great! What else can I do for you?",
    "perfect": "I'm glad to hear that! How can I assist you further?",
    "cool": "Cool! Feel free to ask if you need more help.",
    "good": "Good to know! How can I assist you further?",
    "hello": "Hello! How can I assist you with your abend issues today?",
    "thank you": "You're welcome! If you have any more questions, feel free to ask.",
    "thanks": "You're welcome! Feel free to ask any more questions.",
    "goodbye": "Goodbye! Have a great day!"
}

password_reset_variations = [
    "password reset", "aspire password reset", "password help", "reset aspire password",
    "help with password", "reset my password", "i need a password reset"
]

# Function to match small talk
def match_small_talk(user_input):
    for key in small_talk_responses:
        if fuzz.ratio(user_input, key) > 80:  # Fuzzy matching threshold
            return small_talk_responses[key]
    return None

def match_password_reset(user_input):
    for variation in password_reset_variations:
        if fuzz.ratio(user_input, variation) > 80:  # Fuzzy matching threshold
            return True
    return False

# Function to generate a random password
def generate_random_password(length=15):
    characters = string.ascii_letters + string.digits + string.punctuation
    random_password = ''.join(secrets.choice(characters) for _ in range(length))
    return random_password

# Function to generate a bcrypt hash from a plain text password
def generate_encrypted_password(plain_text_password):
    salt = bcrypt.gensalt(rounds=10, prefix=b"2a")
    hashed_password = bcrypt.hashpw(plain_text_password.encode('utf-8'), salt)
    return hashed_password.decode('utf-8')

# Function to generate a random OTP
def generate_otp():
    return ''.join(secrets.choice(string.digits) for _ in range(6))

# Function to check if user_id exists in SecurityUser table
def check_user_id(user_id):
    try:
        connection = pyodbc.connect(conn_str)
        cursor = connection.cursor()
        query = "SELECT * FROM SecurityUser WHERE user_id = ?"
        cursor.execute(query, user_id)
        result = cursor.fetchone()
        return bool(result)
    except Exception as e:
        logging.error(f"Error checking user_id: {e}")
        return False
    finally:
        if 'connection' in locals():
            connection.close()

# Function to update the password for a given user_id
def update_password(user_id, encrypted_password):
    try:
        connection = pyodbc.connect(conn_str)
        cursor = connection.cursor()
        query = "UPDATE SecurityUser SET password = ?, deactivation_date = NULL WHERE user_id = ?"
        cursor.execute(query, (encrypted_password, user_id))
        connection.commit()
        logging.info(f"Password for User ID {user_id} has been updated to encrypted form and deactivation_date set to NULL.")
    except Exception as e:
        logging.error(f"Error updating password: {e}")
    finally:
        if 'connection' in locals():
            connection.close()

# Function to send email via Outlook with dynamic content
def send_email(to_address, subject="Aspire Password Confirmation", body="", email_type="password_reset"):
    try:
        outlook = win32.Dispatch('outlook.application')
        mail = outlook.CreateItem(0)
        mail.To = to_address
        mail.Subject = subject

        if email_type == "otp":
            mail.HTMLBody = f"""
            <html>
            <body>
                <h2>Aspire Password Reset OTP</h2>
                <p>Dear User,</p>
                <p>Please use the following OTP to reset your password:</p>
                <h3>{body}</h3>
                <p><b>Note:</b> This OTP is valid for a short period. Please use it promptly.</p>
                <p>If you did not request this OTP, please contact your administrator immediately.</p>
                <p>Thank you for using Aspire services.</p>
                <p>Best regards,<br>The Aspire Team</p>
            </body>
            </html>
            """
        else:  # password_reset
            mail.HTMLBody = f"""
            <html>
            <body>
                <h2>Password Reset Confirmation</h2>
                <p>Dear User,</p>
                <p>Your password has been successfully reset. Please find your new login details below:</p>
                <table style="border: 1px solid black; border-collapse: collapse;">
                    <tr>
                        <td style="border: 1px solid black; padding: 8px;"><b>Username:</b></td>
                        <td style="border: 1px solid black; padding: 8px;">{to_address.split('@')[0]}</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid black; padding: 8px;"><b>New Password:</b></td>
                        <td style="border: 1px solid black; padding: 8px;">{body}</td>
                    </tr>
                </table>
                <p><b>Important:</b> Please change this temporary password immediately after you login.</p>
                <p>If you encounter any issues or have any questions, please do not hesitate to contact our support team.</p>
                <p>Thank you for using Aspire services.</p>
                <p>Best regards,<br>The Aspire Team</p>
            </body>
            </html>
            """
        mail.SentOnBehalfOfName = "pratik_bhongade@keybank.com"  # Set the sender email
        mail.Send()
        logging.info(f"Email sent to {to_address} from pratik_bhongade@keybank.com")
    except Exception as e:
        logging.error(f"Failed to send email: {e}")

# Function to load and initialize abend data
def load_and_initialize():
    global abend_data
    abend_data = load_abend_data('abend_data.xlsx')
    initialize_matcher(abend_data)
    logging.debug("Abend data loaded and matcher initialized.")

# Function to get suggestions using fuzzy matching
def get_suggestion(input_text, choices):
    suggestion = process.extractOne(input_text, choices)
    if suggestion[1] > 80:  # Set a threshold for how close the match should be
        return suggestion[0]
    return None

# Function for text-to-speech (TTS)
def speak_text(text):
    tts_engine.say(text)
    tts_engine.runAndWait()

# Initial load and initialize
load_and_initialize()

@app.route('/get_solution', methods=['POST'])
def get_solution():
    global expecting_user_id, expecting_otp, user_id_for_reset, otp_store, suggested_term  # Use global flags and state variables
    user_input = request.json.get('message').strip().lower()
    logging.debug(f"Received user input: {user_input}")

    # Handle Yes/No response to "Did you mean"
    if suggested_term:
        if user_input == "yes":
            response = get_solution_from_entities(suggested_term)
            suggested_term = None  # Reset the suggested term
            speak_text(response.json['solution'])  # Speak the bot's response
            return response
        elif user_input == "no":
            suggested_term = None  # Reset the suggested term
            return jsonify({"solution": "Okay, please provide more details or clarify your query."})
        else:
            return jsonify({"solution": "Please respond with 'yes' or 'no'."})

    # Handle OTP verification flow
    if expecting_otp and user_id_for_reset:
        if user_input == otp_store.get(user_id_for_reset):
            random_password = generate_random_password()
            encrypted_password = generate_encrypted_password(random_password)
            user_email = f"{user_id_for_reset}@keybank.com"
            success_message = f"Password for User ID ***{user_id_for_reset}*** has been updated successfully. The new password has been sent to your email."
            
            update_password(user_id_for_reset, encrypted_password)
            send_email(user_email, body=random_password, email_type="password_reset")
            otp_store.pop(user_id_for_reset)  # Clear the OTP after successful use
            expecting_otp = False
            user_id_for_reset = None

            speak_text(success_message)  # Speak the bot's response
            return jsonify({"solution": success_message})
        else:
            return jsonify({"solution": "Invalid OTP. Please try again."})

    # If the user asked for password reset
    if expecting_user_id:
        if check_user_id(user_input):
            otp = generate_otp()
            user_email = f"{user_input}@keybank.com"
            send_email(user_email, subject="Aspire Password Reset OTP", body=f"Your OTP is: {otp}", email_type="otp")
            otp_store[user_input] = otp
            expecting_user_id = False
            expecting_otp = True
            user_id_for_reset = user_input
            return jsonify({"solution": "An OTP has been sent to your email. Please enter it to proceed with the password reset."})
        else:
            return jsonify({"solution": f"User ID {user_input} not found. Please try again."})

    # Check for small talk with flexible matching
    small_talk_response = match_small_talk(user_input)
    if small_talk_response:
        speak_text(small_talk_response)  # Speak the bot's response
        return jsonify({"solution": small_talk_response})

    # Check for password reset variations
    if match_password_reset(user_input):
        expecting_user_id = True
        return jsonify({"solution": "Please provide your Racf ID to reset your password."})

    # Normal chatbot flow for abend codes
    entities = extract_entities(user_input, abend_data)
    logging.debug(f"Extracted entities: {entities}")

    if entities["greeting"]:
        greeting_response = {
            "hello": "Hello! How can I assist you with your abend issues today?",
            "hi": "Hi there! How can I help you with your abend issues?",
            "hey": "Hey! What abend issue can I help you with?",
            "good morning": "Good morning! How can I assist you today?",
            "good afternoon": "Good afternoon! How can I assist you today?",
            "good evening": "Good evening! How can I assist you today?",
            "how are you": "I'm just a bot, but I'm here to help! How can I assist you?",
            "how is it going": "It's going great! How can I assist you today?",
            "howdy": "Howdy! What abend issue can I help you with?",
            "thanks": "You're welcome! If you have any more questions, feel free to ask.",
            "thank you": "You're welcome! Let me know if there's anything else I can help with.",
            "bye": "Goodbye! Have a great day!",
        }
        response = greeting_response.get(entities["greeting"].lower(), "Hello! How can I assist you today?")
        speak_text(response)  # Speak the bot's response
        return jsonify({"solution": response})

    abend_code = entities["abend_code"]
    abend_name = entities["abend_name"]
    intent = entities["intent"]
    response = None

    if intent == "get_solution" or intent == "unknown":
        if abend_code:
            row = abend_data.loc[abend_data['AbendCode'] == abend_code]
            if not row.empty:
                abend_name = row['AbendName'].values[0]
                solution = row['Solution'].values[0]
                response = f"**Abend Name:** {abend_name}\n\n**Solution:** {solution}"
        elif abend_name:
            row = abend_data.loc[abend_data['AbendName'].str.contains(abend_name, case=False, na=False)]
            if not row.empty:
                abend_code = row['AbendCode'].values[0]
                solution = row['Solution'].values[0]
                response = f"**Abend Code:** {abend_code}\n\n**Solution:** {solution}"
        elif not abend_code:  # Skip "Did you mean" for Abend Codes
            suggestion = get_suggestion(user_input, abend_data['AbendCode'].tolist() + abend_data['AbendName'].tolist())
            if suggestion:
                suggested_term = suggestion  # Store the suggested term
                return jsonify({"solution": f"Did you mean '{suggestion}', please respond with 'yes' or 'no'."})
    
    elif intent == "get_definition":
        if abend_code:
            row = abend_data.loc[abend_data['AbendCode'] == abend_code]
            if not row.empty:
                abend_name = row['AbendName'].values[0]
                response = f"**Abend Name:** {abend_name}\n\n**Definition:** {abend_name}"

        if abend_name and response is None:
            row = abend_data.loc[abend_data['AbendName'].str.contains(abend_name, case=False, na=False)]
            if not row.empty:
                abend_code = row['AbendCode'].values[0]
                response = f"**Abend Code:** {abend_code}\n\n**Definition:** {abend_name}"

    if response:
        speak_text(response)  # Speak the bot's response
        logging.debug(f"Response: {response}")
        return jsonify({"solution": response})
    else:
        fallback_response = "I'm not sure about that. Can you please provide more details or ask a different question?"
        logging.debug("Fallback response.")
        speak_text(fallback_response)  # Speak the bot's response
        return jsonify({"solution": fallback_response})

def get_solution_from_entities(user_input):
    entities = extract_entities(user_input, abend_data)
    abend_code = entities["abend_code"]
    abend_name = entities["abend_name"]
    intent = entities["intent"]
    response = None

    if intent == "get_solution" or intent == "unknown":
        if abend_code:
            row = abend_data.loc[abend_data['AbendCode'] == abend_code]
            if not row.empty:
                abend_name = row['AbendName'].values[0]
                solution = row['Solution'].values[0]
                response = f"**Abend Name:** {abend_name}\n\n**Solution:** {solution}"
        elif abend_name:
            row = abend_data.loc[abend_data['AbendName'].str.contains(abend_name, case=False, na=False)]
            if not row.empty:
                abend_code = row['AbendCode'].values[0]
                solution = row['Solution'].values[0]
                response = f"**Abend Code:** {abend_code}\n\n**Solution:** {solution}"

    if response:
        logging.debug(f"Response: {response}")
        speak_text(response)  # Speak the bot's response
        return jsonify({"solution": response})
    else:
        fallback_response = "I'm not sure about that. Can you please provide more details or ask a different question?"
        logging.debug("Fallback response.")
        speak_text(fallback_response)  # Speak the bot's response
        return jsonify({"solution": fallback_response})

@app.route('/refresh_data', methods=['POST'])
def refresh_data():
    load_and_initialize()
    return jsonify({"status": "Data refreshed successfully"})

if __name__ == '__main__':
    app.run(debug=True)
